<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Central de Jogos</title>
    <!-- Inclui a biblioteca Tailwind CSS para estilização -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fontes do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos CSS personalizados */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #e0f7fa, #b2ebf2);
            color: #006064;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* Container principal - Centraliza e define tamanho */
        .game-container {
            width: 100%;
            max-width: 1000px; 
            border-radius: 25px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            padding: 25px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
            
            /* --- Borda com Imagem --- */
            border: 15px solid transparent; 
            background-image: linear-gradient(#ffffff, #ffffff), url('https://i.postimg.cc/CKdYnGmr/b7cfca-ecba34bc03024b7280cf546ab72057a3.jpg');
            background-origin: padding-box, border-box;
            background-clip: padding-box, border-box;
            background-size: cover; 
            /* --------------------------- */
        }

        /* Título do jogo */
        .game-header {
            font-size: 2.5rem;
            font-weight: 700;
            color: #00796b;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Estilos para o menu de abas */
        .tab-menu {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #b2ebf2;
        }

        .tab-btn {
            padding: 10px 20px;
            font-size: 1.1rem;
            font-weight: 600;
            color: #00796b;
            background-color: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px 10px 0 0;
            margin: 0 5px;
        }

        .tab-btn.active {
            background-color: #e0f7fa;
            border-bottom: 3px solid #00bfa5;
            color: #004d40;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
        }

        .tab-content {
            padding: 15px;
            border-radius: 0 0 20px 20px;
        }

        /* Estilo do botão padrão */
        .btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background: linear-gradient(180deg, #00bfa5, #00897b);
            color: #fff;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            background: linear-gradient(180deg, #00897b, #00695c);
        }

        /* --- Estilos Confetti Game --- */
        #confettiCanvas {
            width: 100%;
            height: auto;
            min-height: 450px;
            background-color: #f0fdfa;
            background-image: url('https://i.postimg.cc/wBvjgdWm/054d7f95-28c1-4cca-9f0a-6262b04f0bab.png'); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border: 2px solid #b2ebf2;
            border-radius: 20px;
            cursor: pointer;
        }

        /* --- Estilos Customizador de Rosto --- */
        #faceCustomizer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            min-height: 500px;
        }

        #drawingArea {
            position: relative;
            width: 100%;
            max-width: 500px; 
            padding-top: 100%; 
            height: 0;
            background-image: url('https://i.postimg.cc/Wb4BsmdQ/ddddddd.jpg'); 
            background-size: cover;
            background-position: center;
            border: 2px solid #a7ffeb;
            border-radius: 15px;
            overflow: hidden; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        #drawingArea > * {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #drawingCanvas {
            z-index: 100;
            cursor: default; 
            pointer-events: none;
        }
        
        #drawingCanvas.drawing-active {
            pointer-events: auto;
        }

        .drawing-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: #f0f7f9;
            border-radius: 10px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        /* Estilos para os botões de ferramenta */
        .tool-btn {
            border: 2px solid transparent;
            color: #00796b;
            background-color: #f0f7f9;
        }
        .tool-btn.active {
            border: 2px solid #00bfa5;
            box-shadow: 0 0 5px rgba(0, 180, 150, 0.5);
            color: #004d40;
            background-color: #e0f7fa;
        }
        .tool-btn:hover:not(.active) {
            background-color: #e0f7fa;
        }

        /* --- ESTILO: CONTROLE ROTATÓRIO DO PINCEL --- */
        #brushKnobContainer {
            width: 48px;
            height: 48px;
            position: relative;
            user-select: none;
            touch-action: none;
        }
        #brushKnob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(145deg, #00bfa5, #004d40);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), inset 0 2px 5px rgba(255, 255, 255, 0.5);
            cursor: grab;
            transition: box-shadow 0.1s;
        }
        #brushKnob.active {
            cursor: grabbing;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(255, 255, 255, 0.3);
        }
        #knobHandle {
            position: absolute;
            top: 5px; 
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background-color: #ffeb3b; 
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        #accessoriesContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            padding: 15px;
            background-color: #e0f2f7;
            border-radius: 15px;
            width: 100%;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .accessory-item {
            width: 90px;
            height: 90px;
            background-color: #ffffff;
            border: 2px solid #b2ebf2;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer; 
            transition: all 0.2s;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            font-size: 0.75rem;
            color: #00796b;
        }

        .accessory-item img {
            max-width: 90%;
            max-height: 60%;
            pointer-events: none; 
        }

        .accessory-item:hover {
            transform: scale(1.05);
            border-color: #00bfa5;
        }

        /* --- ESTILOS DO ACCESSORY WRAPPER --- */
        .accessory-wrapper {
            z-index: 10;
            position: absolute;
            cursor: grab;
            user-select: none;
            touch-action: none; 
            line-height: 0; 
            box-sizing: content-box; 
        }

        .accessory-wrapper.active {
            border: 2px dashed #ff4081; 
            box-shadow: 0 0 0 3px rgba(255, 64, 129, 0.5);
            z-index: 11; 
        }

        .accessory-wrapper img {
            pointer-events: none; 
            display: block;
            width: 100%;
            height: 100%;
            object-fit: fill; 
        }

        .resize-handle {
            position: absolute;
            width: 30px; 
            height: 30px; 
            background: #FFEB3B; 
            border: 3px solid #673AB7; 
            border-radius: 6px; 
            z-index: 2000; 
            box-sizing: border-box;
            opacity: 0; 
            transition: opacity 0.2s ease;
        }
        
        /* NOVO ESTILO: Botão de Deletar (Substitui o resize NE) */
        .delete-handle {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #ef4444; /* Vermelho */
            border: 2px solid #ffffff;
            border-radius: 50%;
            z-index: 2001; /* Maior que resize */
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-family: sans-serif;
            top: -15px;
            right: -15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .handle-nw { top: -15px; left: -15px; cursor: nwse-resize; }
        /* .handle-ne foi removido para dar lugar ao delete */
        .handle-sw { bottom: -15px; left: -15px; cursor: nesw-resize; }
        .handle-se { bottom: -15px; right: -15px; cursor: nwse-resize; }

        .rotate-handle {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #2979FF; 
            border: 3px solid #1A237E; 
            border-radius: 50%; 
            z-index: 2000;
            cursor: grab; 
            top: -45px; 
            left: 50%;
            transform: translateX(-50%);
            opacity: 0; 
            transition: opacity 0.2s ease;
            box-sizing: border-box;
        }
        
        .accessory-wrapper.active .resize-handle,
        .accessory-wrapper.active .rotate-handle,
        .accessory-wrapper.active .delete-handle {
            opacity: 1;
        }

        /* --- AJUSTES PARA CELULAR (RESPONSIVIDADE) --- */
        @media (max-width: 640px) {
            body {
                padding: 10px; /* Menos margem no corpo */
            }
            .game-container {
                padding: 10px; /* Menos padding interno */
                border-width: 8px; /* Borda decorativa mais fina */
                width: 100%;
            }
            .game-header {
                font-size: 1.75rem; /* Título um pouco menor */
                margin-bottom: 10px;
            }
            #accessoriesContainer {
                gap: 8px;
            }
            .accessory-item {
                width: 70px; /* Botões de acessório menores para caber mais */
                height: 70px;
            }
            #drawingArea {
                /* Garante que ocupe todo o espaço disponível */
                width: 100%;
            }
        }
    </style>
</head>
<body class="bg-gray-200 flex items-center justify-center p-4">

    <div class="game-container">
        <h1 class="game-header">Central de Jogos</h1>
        
        <!-- Menu de Abas -->
        <div class="tab-menu" id="tabMenu">
            <button class="tab-btn active" data-game="confetti">Confetche!</button>
            <button class="tab-btn" data-game="faceCustomizer">Me deixe bem bonito!</button>
        </div>

        <!-- Conteúdo da Aba Ativa -->
        <div id="gameContent" class="tab-content">
            <!-- Conteúdo será injetado pelo JavaScript -->
        </div>
        
        <!-- Modal de Confirmação Customizado -->
        <div id="removeConfirmModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 transition-opacity duration-300 opacity-0 pointer-events-none">
            <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full transform scale-90 transition-transform duration-300">
                <h3 class="text-xl font-bold text-teal-800 mb-4">Remover Acessório</h3>
                <p class="text-gray-700 mb-6">Deseja remover este item da imagem?</p>
                <div class="flex justify-end space-x-3">
                    <button id="cancelRemove" class="px-4 py-2 text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-100 transition">Cancelar</button>
                    <button id="confirmRemove" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition">Remover</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- Variáveis Globais de Jogo e Estado ---
        let currentGame = 'confetti'; 
        let currentTool = 'select'; 
        
        // --- Variáveis de Estado do Customizador ---
        let activeAccessory = null; 
        let currentAction = null; 
        let initialMouseX, initialMouseY; 
        let initialWidth, initialHeight; 
        let initialElementLeft, initialElementTop; 
        let initialAngle = 0;
        let initialRotation = 0;

        const MIN_ACCESSORY_SIZE = 30; 
        
        // --- Variáveis do Controle Rotatório do Pincel ---
        let isRotatingBrush = false;
        let knobCenterX, knobCenterY;
        let initialKnobAngle = 0;
        let initialKnobBrushSize = 0;
        let currentKnobRotation = 0; 
        const MAX_BRUSH_SIZE = 20;
        const MIN_BRUSH_SIZE = 1;
        const MAX_VISUAL_ROTATION = 340; 
        const DEGREES_PER_UNIT = 18;


        // --- Funções de Utilitário para TTS (Áudio) ---
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); }
            return window.btoa(binary);
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1; const bitsPerSample = 16; const dataLength = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataLength); const view = new DataView(buffer); let offset = 0;
            function writeString(str, view, offset) { for (let i = 0; i < str.length; i++) { view.setUint8(offset + i, str.charCodeAt(i)); } }
            writeString('RIFF', view, offset); offset += 4;
            view.setUint32(offset, 36 + dataLength, true); offset += 4;
            writeString('WAVE', view, offset); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, 1, true); offset += 2;
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * (bitsPerSample / 8), true); offset += 4;
            view.setUint16(offset, numChannels * (bitsPerSample / 8), true); offset += 2;
            view.setUint16(offset, bitsPerSample, true); offset += 2;
            writeString('data', view, offset); offset += 4;
            view.setUint32(offset, dataLength, true); offset += 4;
            for (let i = 0; i < pcmData.length; i++, offset += 2) { view.setInt16(offset, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429 && response.ok) { return response; }
                    if (response.status === 429 && i < maxRetries - 1) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    throw new Error(`API request failed with status ${response.status}`);
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error("Maximum retries reached for API call.");
        }

        // --- Confetti Game Variables and Logic ---
        let confettiGameInstance = null; 
        let coughSound = null;
        let isSoundLoading = false;
        let confettiScore = 0; 
        const MAX_CONF_SCORE = 50;
        let showFinalMessage = false;
        let messageStartTime = 0;
        const MESSAGE_DURATION = 5000;
        const BLINK_INTERVAL = 300;
        let confettiParticles = []; 
        let coughedConfetti = [];
        let confettiMan = { x: 0, y: 0, width: 200, height: 240, dx: 3, dy: 0, mouthOpen: false }; 
        let isConfettiGameRunning = false; 
        let lastConfettiUpdateTime = 0; 
        let mouthOpenInterval = 1200;
        const mouthOpenDuration = 400;
        
        const manImages = { idle: new Image(), open: new Image(), cough: new Image(), cough2: new Image() };
        manImages.idle.src = 'https://i.postimg.cc/XvhMHHx2/fechando.png';
        manImages.open.src = 'https://i.postimg.cc/kgTP8XSP/6a575d21-32c4-4876-abc2-99943e746c78.png';
        manImages.cough.src = 'https://i.postimg.cc/jS0bKFrB/tosse-esse-sim.png';
        manImages.cough2.src = 'https://i.postimg.cc/gjmgN39S/tosse-esse-sim2.png';
        
        const placeholderURL = (text) => `https://placehold.co/100x120/43a047/ffffff?text=${text}`;
        manImages.idle.onerror = () => manImages.idle.src = placeholderURL('Idle');
        manImages.open.onerror = () => manImages.open.src = placeholderURL('Open');
        manImages.cough.onerror = () => manImages.cough.src = placeholderURL('Cough1');
        manImages.cough2.onerror = () => manImages.cough2.src = placeholderURL('Cough2');
        let currentManImage = manImages.idle;

        async function loadCoughSound() {
            if (coughSound || isSoundLoading) return;
            isSoundLoading = true;
            try {
                const prompt = "Say with a raspy texture: cough";
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Algieba" } } }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                const response = await fetchWithBackoff(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                    const binaryString = atob(audioData); const len = binaryString.length; const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
                    const pcmData = new Int16Array(bytes.buffer);
                    const wavBlob = pcmToWav(pcmData, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    coughSound = new Audio(audioUrl);
                    coughSound.volume = 0.5;
                } else { console.error("Dados de áudio inválidos na resposta da API."); }
            } catch (error) { console.error("Erro ao carregar o áudio:", error); } 
            finally { isSoundLoading = false; }
        }
        
        function resizeConfettiCanvas(canvas, manObj) { 
            if (!canvas) return; 
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            manObj.x = canvas.width / 2 - manObj.width / 2;
            manObj.y = canvas.height - manObj.height;
        }

        function drawConfettiMan(ctx) { ctx.drawImage(currentManImage, confettiMan.x, confettiMan.y, confettiMan.width, confettiMan.height); }
        function drawConfettiParticles(ctx) {
            confettiParticles.forEach(c => {
                ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
            });
        }
        function drawCoughedConfettiParticles(ctx) {
            coughedConfetti.forEach(c => {
                ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
            });
        }

        function drawConfettiMessage(ctx, canvas) {
            if (!showFinalMessage) return;
            const timeElapsed = Date.now() - messageStartTime;
            if (Math.floor(timeElapsed / BLINK_INTERVAL) % 2 === 0) {
                ctx.font = 'bold 72px Inter, sans-serif'; ctx.fillStyle = 'red'; ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 15;
                ctx.fillText("DEU CHEGA!", canvas.width / 2, canvas.height / 2);
                ctx.shadowBlur = 0;
            }
        }

        function coughConfettiAction() {
            if (coughSound) { coughSound.currentTime = 0; coughSound.play().catch(e => console.log("Sound autoplay failed.")); }
            const numParticles = Math.floor(Math.random() * 30) + 15;
            const mouthX = confettiMan.x + confettiMan.width / 2; const mouthY = confettiMan.y + 50; 
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                coughedConfetti.push({
                    x: mouthX, y: mouthY, radius: Math.random() * 6 + 3,
                    color: `hsl(${Math.random() * 360}, 100%, 60%)`,
                    dx: Math.cos(angle) * (Math.random() * 6 + 3), dy: Math.sin(angle) * (Math.random() * 6 + 3),
                    life: 120
                });
            }
            currentManImage = manImages.cough;
            setTimeout(() => { currentManImage = manImages.cough2; setTimeout(() => { currentManImage = manImages.idle; }, 250); }, 250);
        }
        
        function updateConfettiGameLoop() {
            if (!isConfettiGameRunning || currentGame !== 'confetti') {
                confettiGameInstance = null; 
                return; 
            }
            
            const canvas = document.getElementById('confettiCanvas');
            if (!canvas) {
                isConfettiGameRunning = false;
                confettiGameInstance = null;
                return;
            }

            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('scoreDisplay');
            
            confettiMan.x += confettiMan.dx;
            if (confettiMan.x + confettiMan.width > canvas.width || confettiMan.x < 0) { confettiMan.dx *= -1; }

            const currentTime = Date.now();
            if (currentTime - lastConfettiUpdateTime > mouthOpenInterval) {
                confettiMan.mouthOpen = true; lastConfettiUpdateTime = currentTime; currentManImage = manImages.open;
                setTimeout(() => { confettiMan.mouthOpen = false; currentManImage = manImages.idle; }, mouthOpenDuration);
            }

            confettiParticles.forEach((c, index) => {
                c.y += c.speed; 
                const mouthXMin = confettiMan.x + confettiMan.width / 2 - 50;
                const mouthXMax = confettiMan.x + confettiMan.width / 2 + 50;
                const mouthYMin = confettiMan.y;
                const mouthYMax = confettiMan.y + 50;

                if (confettiMan.mouthOpen && c.x >= mouthXMin && c.x <= mouthXMax && c.y >= mouthYMin && c.y <= mouthYMax) {
                    if (confettiScore === MAX_CONF_SCORE && !showFinalMessage) { showFinalMessage = true; messageStartTime = Date.now(); }
                    confettiScore++;
                    mouthOpenInterval = Math.max(500, mouthOpenInterval * 0.95);
                    if (scoreDisplay) scoreDisplay.textContent = confettiScore;
                    confettiParticles.splice(index, 1);
                    coughConfettiAction();
                    lastConfettiUpdateTime = currentTime; confettiMan.mouthOpen = false;
                }
            });

            coughedConfetti.forEach((c, index) => {
                c.x += c.dx; c.y += c.dy; c.life--;
                if (c.life <= 0) { coughedConfetti.splice(index, 1); }
            });

            confettiParticles = confettiParticles.filter(c => c.y - c.radius < canvas.height); 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (showFinalMessage && (Date.now() - messageStartTime) > MESSAGE_DURATION) { showFinalMessage = false; }

            drawConfettiMan(ctx); drawConfettiParticles(ctx); drawCoughedConfettiParticles(ctx); drawConfettiMessage(ctx, canvas);
            
            confettiGameInstance = requestAnimationFrame(updateConfettiGameLoop);
        }

        function startConfettiGame() {
            confettiScore = 0; showFinalMessage = false; 
            const scoreDisplay = document.getElementById('scoreDisplay');
            if (scoreDisplay) scoreDisplay.textContent = confettiScore;

            confettiParticles = []; coughedConfetti = [];
            const canvas = document.getElementById('confettiCanvas');
            if (!canvas) return; 
            
            resizeConfettiCanvas(canvas, confettiMan); 
            confettiMan.dx = 3; 
            isConfettiGameRunning = true; 
            lastConfettiUpdateTime = Date.now();
            mouthOpenInterval = 1200;
            
            if (!confettiGameInstance) {
                 confettiGameInstance = requestAnimationFrame(updateConfettiGameLoop);
            }
        }

        function setupConfettiListeners(canvas) {
            const handleConfettiClick = (e) => {
                 if (isConfettiGameRunning && currentGame === 'confetti') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    confettiParticles.push({
                        x: x, y: y, radius: 6, color: `hsl(${Math.random() * 360}, 100%, 60%)`, speed: -6 
                    });
                }
            };

            const handleConfettiResize = () => {
                if (canvas && currentGame === 'confetti') resizeConfettiCanvas(canvas, confettiMan);
            };

            canvas.removeEventListener('click', canvas.currentClickHandler);
            window.removeEventListener('resize', window.currentConfettiResizeHandler);
            
            canvas.addEventListener('click', handleConfettiClick);
            window.addEventListener('resize', handleConfettiResize);

            canvas.currentClickHandler = handleConfettiClick;
            window.currentConfettiResizeHandler = handleConfettiResize;
        }

        function renderConfettiGameContent() {
            document.getElementById('gameContent').innerHTML = `
                <h2 class="text-2xl font-bold text-teal-700">Vamos festejar!</h2>
                <div class="game-info">
                    Pontuação: <span id="scoreDisplay">${confettiScore}</span> 
                </div>
                <canvas id="confettiCanvas"></canvas>
                <button id="startButton" class="btn">Começar Jogo</button>
            `;
            
            const canvas = document.getElementById('confettiCanvas');
            const startButton = document.getElementById('startButton');

            setupConfettiListeners(canvas);
            
            startButton.addEventListener('click', async () => {
                if (!isSoundLoading && !coughSound) {
                    startButton.textContent = "Carregando som... (Aguarde)";
                    await loadCoughSound();
                }
                if (!isSoundLoading) {
                    startConfettiGame();
                    startButton.textContent = "Reiniciar Jogo";
                }
            });
            
            if (!confettiGameInstance && currentGame === 'confetti') {
                 isConfettiGameRunning = true;
                 confettiGameInstance = requestAnimationFrame(updateConfettiGameLoop);
            } else if (currentGame === 'confetti') {
                 isConfettiGameRunning = true;
            }
            
            manImages.idle.onload = () => { resizeConfettiCanvas(canvas, confettiMan); };
            if (manImages.idle.complete) resizeConfettiCanvas(canvas, confettiMan);
        }
        
        // --- Lógica do Customizador de Rosto ---
        let drawingCanvas = null;
        let drawingCtx = null;
        let isDrawing = false;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let accessories = []; 

        const FACE_IMAGE_URL = 'https://i.postimg.cc/Wb4BsmdQ/ddddddd.jpg';
        let faceImage = new Image();
        faceImage.src = FACE_IMAGE_URL;
        
        const defaultAccessories = [
            { name: "Peruca Curta", src: "https://i.postimg.cc/XvxPGjJw/perucawws.png", w: 150, h: 150 }, 
            { name: "Peruca Vermelha", src: "https://i.postimg.cc/XJJz9RGt/perucas.png", w: 150, h: 150 },
            { name: "Casal da Live", src: "https://i.postimg.cc/kDrY3D1P/SACO-OVO.png", w: 180, h: 180 }, 
            { name: "Bigode", src: "https://i.postimg.cc/m2j4BwSM/bigode.png", w: 80, h: 40 },
            { name: "Maquiagem", src: "https://i.postimg.cc/XY2nc8Gd/make.png", w: 180, h: 150 },
            { name: "Chapéu", src: "https://i.postimg.cc/MpjnsHR1/Captura-de-tela-2025-11-30-191447.png", w: 100, h: 80 },
            { name: "Peruca Loira", src: "https://i.postimg.cc/N0w4gWkT/Captura-de-tela-2025-11-30-190254.png", w: 150, h: 150 },
            { name: "Boca", src: "https://i.postimg.cc/RZkLGqsZ/Captura-de-tela-2025-11-30-195023.png", w: 80, h: 40 },
            { name: "Cabelo", src: "https://i.postimg.cc/MGcKZpq9/a214595cb778d15d02a04495c94e14b3.png", w: 150, h: 150 },
            { name: "Maquiagem Olho", src: "https://i.postimg.cc/D058JpDM/ddddddd.png", w: 150, h: 80 }
        ];
        
        function calculateAngle(cx, cy, px, py) {
            return Math.atan2(py - cy, px - cx);
        }

        // --- FUNÇÕES AUXILIARES DE ESTADO DO CUSTOMIZADOR ---
        function getCoords(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { clientX, clientY };
        }

        function setActiveAccessory(element) {
            document.querySelectorAll('.accessory-wrapper').forEach(el => {
                if (el !== element) {
                    el.classList.remove('active');
                    el.style.zIndex = 10;
                }
            });
            
            if (element) {
                element.classList.add('active');
                element.style.zIndex = 11; 
                activeAccessory = element;
            } else {
                activeAccessory = null;
            }
        }

        // --- LÓGICA PRINCIPAL DE ARRASTO, REDIMENSIONAMENTO E ROTAÇÃO ---

        function startAction(e) {
            const drawingArea = document.getElementById('drawingArea');
            if (!drawingArea) return;
            
            const target = e.target;
            const { clientX, clientY } = getCoords(e);
            
            if (target.tagName === 'INPUT' || target.tagName === 'LABEL' || (target.tagName === 'BUTTON' && target.id === 'clearDrawingBtn') || target.id === 'brushKnob' || target.id === 'knobHandle') {
                return;
            }
            
            // Check if delete handle is clicked
            if (target.classList.contains('delete-handle')) {
                 if (activeAccessory) {
                    showRemoveModal(activeAccessory);
                 }
                 e.preventDefault();
                 return;
            }

            if (currentTool !== 'select') {
                setActiveAccessory(null); 
                return;
            }

            if (target.classList.contains('resize-handle')) {
                currentAction = target.classList.contains('handle-nw') ? 'resize-nw' :
                                target.classList.contains('handle-ne') ? 'resize-ne' :
                                target.classList.contains('handle-sw') ? 'resize-sw' :
                                'resize-se'; 
                
                activeAccessory = target.parentElement; 
                e.preventDefault();

            } else if (target.classList.contains('rotate-handle')) {
                currentAction = 'rotate';
                activeAccessory = target.parentElement;
                const rect = activeAccessory.getBoundingClientRect();
                knobCenterX = rect.left + rect.width / 2;
                knobCenterY = rect.top + rect.height / 2;
                initialAngle = calculateAngle(knobCenterX, knobCenterY, clientX, clientY);
                initialRotation = parseFloat(activeAccessory.getAttribute('data-rotation') || 0);
                e.preventDefault();
            
            } else if (target.classList.contains('accessory-wrapper')) {
                currentAction = 'drag';
                setActiveAccessory(target); 
                initialMouseX = clientX;
                initialMouseY = clientY;
                initialElementLeft = parseFloat(target.style.left) || 0;
                initialElementTop = parseFloat(target.style.top) || 0;
                e.preventDefault();
            
            } else if (target.id === 'drawingArea') {
                setActiveAccessory(null);
            }
            
            if (activeAccessory && (currentAction === 'drag' || currentAction.startsWith('resize') || currentAction === 'rotate')) {
                initialMouseX = clientX;
                initialMouseY = clientY;
                initialWidth = activeAccessory.offsetWidth;
                initialHeight = activeAccessory.offsetHeight;
                initialElementLeft = parseFloat(activeAccessory.style.left) || 0;
                initialElementTop = parseFloat(activeAccessory.style.top) || 0;
            }
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                isDrawing = true;
                draw(clientX, clientY);
            }
            
            document.addEventListener('mousemove', moveAction);
            document.addEventListener('mouseup', stopAction);
            document.addEventListener('touchmove', moveAction, { passive: false });
            document.addEventListener('touchend', stopAction);
        }

        function moveAction(e) {
            const { clientX, clientY } = getCoords(e);
            const dx = clientX - initialMouseX;
            const dy = clientY - initialMouseY;
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                if (isDrawing) { draw(clientX, clientY); }
                return;
            }
            
            if (!activeAccessory || !currentAction) return;
            e.preventDefault();
            
            if (currentAction === 'drag') {
                let newLeft = initialElementLeft + dx;
                let newTop = initialElementTop + dy;
                
                activeAccessory.style.left = `${newLeft}px`;
                activeAccessory.style.top = `${newTop}px`;
            
            } else if (currentAction.startsWith('resize')) {
                let newWidth = initialWidth;
                let newHeight = initialHeight;
                let newLeft = initialElementLeft;
                let newTop = initialElementTop;

                switch (currentAction) {
                    case 'resize-nw':
                        newWidth = initialWidth - dx;
                        newHeight = initialHeight - dy;
                        newLeft = initialElementLeft + dx;
                        newTop = initialElementTop + dy;
                        break;
                    case 'resize-ne':
                        newWidth = initialWidth + dx;
                        newHeight = initialHeight - dy;
                        newTop = initialElementTop + dy;
                        break;
                    case 'resize-sw':
                        newWidth = initialWidth - dx;
                        newHeight = initialHeight + dy;
                        newLeft = initialElementLeft + dx;
                        break;
                    case 'resize-se':
                        newWidth = initialWidth + dx;
                        newHeight = initialHeight + dy;
                        break;
                }

                if (newWidth > MIN_ACCESSORY_SIZE) {
                    activeAccessory.style.width = `${newWidth}px`;
                    if (currentAction.includes('w')) activeAccessory.style.left = `${newLeft}px`;
                }

                if (newHeight > MIN_ACCESSORY_SIZE) {
                    activeAccessory.style.height = `${newHeight}px`;
                    if (currentAction.includes('n')) activeAccessory.style.top = `${newTop}px`;
                }
            
            } else if (currentAction === 'rotate') {
                const currentAngle = calculateAngle(knobCenterX, knobCenterY, clientX, clientY);
                const angleDiff = currentAngle - initialAngle;
                let newRotation = initialRotation + (angleDiff * (180 / Math.PI));
                activeAccessory.style.transform = `rotate(${newRotation}deg)`;
                activeAccessory.setAttribute('data-rotation', newRotation.toFixed(2));
            }
        }

        function stopAction() {
            isDrawing = false;
            currentAction = null;
            
            document.removeEventListener('mousemove', moveAction);
            document.removeEventListener('mouseup', stopAction);
            document.removeEventListener('touchmove', moveAction);
            document.removeEventListener('touchend', stopAction);
        }

        // Lógica de Desenho e Pincel/Borracha
        function draw(clientX, clientY) {
            if (!isDrawing || !drawingCtx || !drawingCanvas) return;
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            if (currentTool === 'eraser') {
                drawingCtx.globalCompositeOperation = 'destination-out';
            } else if (currentTool === 'brush') {
                drawingCtx.globalCompositeOperation = 'source-over';
                drawingCtx.strokeStyle = currentColor;
            }

            drawingCtx.lineWidth = currentBrushSize;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();
            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);
        }
        
        function handleDrawingStart(e) {
            if (currentTool !== 'brush' && currentTool !== 'eraser') return;
            e.preventDefault();
            const { clientX, clientY } = getCoords(e);
            const rect = drawingCanvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            isDrawing = true;
            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);

            document.addEventListener('mousemove', moveAction);
            document.addEventListener('mouseup', stopAction);
            document.addEventListener('touchmove', moveAction, { passive: false });
            document.addEventListener('touchend', stopAction);
        }

        // Lógica do Pincel Rotatório
        function updateBrushKnob(rotation) {
            const knob = document.getElementById('brushKnob');
            if (knob) {
                knob.style.transform = `rotate(${rotation}deg)`;
                currentKnobRotation = rotation;
                
                const sizeRange = MAX_BRUSH_SIZE - MIN_BRUSH_SIZE;
                const normalizedRotation = (rotation + 360) % 360; 
                const sizeFraction = Math.min(1, normalizedRotation / MAX_VISUAL_ROTATION);
                currentBrushSize = Math.round(MIN_BRUSH_SIZE + (sizeFraction * sizeRange));
                document.getElementById('brushSizeLabel').textContent = `${currentBrushSize}px`;
            }
        }
        
        function startBrushKnobRotation(e) {
            const knob = document.getElementById('brushKnob');
            if (!knob) return;
            const { clientX, clientY } = getCoords(e);
            
            const rect = knob.parentElement.getBoundingClientRect();
            knobCenterX = rect.left + rect.width / 2;
            knobCenterY = rect.top + rect.height / 2;
            
            isRotatingBrush = true;
            knob.classList.add('active');
            initialKnobAngle = calculateAngle(knobCenterX, knobCenterY, clientX, clientY);
            initialKnobRotation = currentKnobRotation;
            
            document.addEventListener('mousemove', moveBrushKnob);
            document.addEventListener('mouseup', stopBrushKnobRotation);
            document.addEventListener('touchmove', moveBrushKnob, { passive: false });
            document.addEventListener('touchend', stopBrushKnobRotation);
        }

        function moveBrushKnob(e) {
            if (!isRotatingBrush) return;
            e.preventDefault();
            
            const { clientX, clientY } = getCoords(e);
            const currentAngle = calculateAngle(knobCenterX, knobCenterY, clientX, clientY);
            const angleDiff = currentAngle - initialKnobAngle;
            let newRotation = initialKnobRotation + (angleDiff * (180 / Math.PI));
            
            newRotation = Math.max(0, Math.min(newRotation, MAX_VISUAL_ROTATION));
            
            updateBrushKnob(newRotation);
        }

        function stopBrushKnobRotation() {
            isRotatingBrush = false;
            const knob = document.getElementById('brushKnob');
            if (knob) knob.classList.remove('active');
            
            document.removeEventListener('mousemove', moveBrushKnob);
            document.removeEventListener('mouseup', stopBrushKnobRotation);
            document.removeEventListener('touchmove', moveBrushKnob);
            document.removeEventListener('touchend', stopBrushKnobRotation);
        }

        // --- Função para adicionar Acessório ---
        function addAccessory(accessory) {
            const drawingArea = document.getElementById('drawingArea');
            if (!drawingArea) return;
            
            const areaSize = drawingArea.offsetWidth;
            
            // Lógica de Escala Responsiva
            // O tamanho original dos acessórios foi pensado para uma tela de 500px de largura.
            // Se a tela for menor (celular), escalamos o acessório para manter a proporção visual.
            const REFERENCE_WIDTH = 500;
            const scale = Math.min(1, areaSize / REFERENCE_WIDTH); // Não aumenta além do original, apenas reduz
            
            const scaledW = accessory.w * scale;
            const scaledH = accessory.h * scale;

            const newElement = document.createElement('div');
            newElement.classList.add('accessory-wrapper');
            newElement.style.width = `${scaledW}px`;
            newElement.style.height = `${scaledH}px`;
            
            // Centraliza o acessório usando a dimensão calculada
            newElement.style.left = `${(areaSize / 2) - (scaledW / 2)}px`;
            newElement.style.top = `${(areaSize / 2) - (scaledH / 2)}px`;

            newElement.style.transform = 'rotate(0deg)';
            newElement.setAttribute('data-rotation', '0');
            
            const img = document.createElement('img');
            img.src = accessory.src;
            img.onerror = () => { img.src = `https://placehold.co/${accessory.w}x${accessory.h}/d32f2f/ffffff?text=Erro`; };
            newElement.appendChild(img);

            // Adicionar manipuladores de redimensionamento (Exceto NE, que vira delete)
            ['nw', 'sw', 'se'].forEach(pos => {
                const handle = document.createElement('div');
                handle.classList.add('resize-handle', `handle-${pos}`);
                newElement.appendChild(handle);
            });

            // Adicionar manipulador de rotação
            const rotateHandle = document.createElement('div');
            rotateHandle.classList.add('rotate-handle');
            newElement.appendChild(rotateHandle);
            
            // Adicionar botão de deletar (No lugar do NE)
            const deleteHandle = document.createElement('div');
            deleteHandle.classList.add('delete-handle');
            deleteHandle.innerHTML = 'X';
            newElement.appendChild(deleteHandle);
            
            newElement.addEventListener('dblclick', () => showRemoveModal(newElement));
            newElement.addEventListener('contextmenu', (e) => { e.preventDefault(); showRemoveModal(newElement); });
            newElement.addEventListener('mousedown', (e) => startAction(e));
            newElement.addEventListener('touchstart', (e) => startAction(e), { passive: false });
            newElement.querySelector('.rotate-handle').addEventListener('mousedown', (e) => startAction(e));
            newElement.querySelector('.rotate-handle').addEventListener('touchstart', (e) => startAction(e), { passive: false });


            drawingArea.appendChild(newElement);
            setActiveAccessory(newElement);
            accessories.push(newElement);
        }
        
        function showRemoveModal(elementToRemove) {
            const modal = document.getElementById('removeConfirmModal');
            const confirmBtn = document.getElementById('confirmRemove');
            
            modal.classList.remove('opacity-0', 'pointer-events-none');
            modal.querySelector('.scale-90').classList.remove('scale-90');

            const handler = () => {
                if (elementToRemove.parentElement) {
                    elementToRemove.parentElement.removeChild(elementToRemove);
                    accessories = accessories.filter(acc => acc !== elementToRemove);
                }
                hideRemoveModal();
                confirmBtn.removeEventListener('click', handler);
                setActiveAccessory(null); // Clear selection
            };

            confirmBtn.addEventListener('click', handler);
        }

        function hideRemoveModal() {
            const modal = document.getElementById('removeConfirmModal');
            modal.classList.add('opacity-0', 'pointer-events-none');
            modal.querySelector('.scale-90').classList.add('scale-90');
            document.getElementById('confirmRemove').replaceWith(document.getElementById('confirmRemove').cloneNode(true)); // Limpa listener
            document.getElementById('cancelRemove').removeEventListener('click', hideRemoveModal);
        }

        // --- Renderização do Customizador ---
        function renderFaceCustomizerContent() {
            document.getElementById('gameContent').innerHTML = `
                <div id="faceCustomizer">
                    <!-- Área de Desenho e Visualização -->
                    <div id="drawingArea">
                        <canvas id="drawingCanvas"></canvas>
                        <!-- LIXEIRA REMOVIDA DAQUI -->
                    </div>

                    <!-- Controles de Desenho/Seleção -->
                    <div class="drawing-controls">
                        <button id="toolSelect" class="tool-btn btn-sm px-4 py-2 rounded-lg text-lg active" title="Selecionar Acessórios">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6"><path d="M15 3l4 4L8 19l-4 4L3 20l4-4 11-11z"/></svg>
                        </button>
                        <button id="toolBrush" class="tool-btn btn-sm px-4 py-2 rounded-lg text-lg" title="Pincel">
                            <img src="https://i.postimg.cc/52x4ZmXT/hhhhhhhhhhhh.png" alt="Pincel" class="w-6 h-6 object-contain">
                        </button>
                        <button id="toolEraser" class="tool-btn btn-sm px-4 py-2 rounded-lg text-lg" title="Borracha">
                            <img src="https://i.postimg.cc/pdr2dXYQ/gggggggggggggg.png" alt="Borracha" class="w-6 h-6 object-contain">
                        </button>
                        
                        <!-- BOTÃO DE LIXEIRA REMOVIDO DA BARRA -->

                        <input type="color" id="brushColor" value="#000000" class="w-10 h-10 p-1 border-2 border-teal-500 rounded-lg cursor-pointer" title="Cor do Pincel">
                        
                        <!-- Controle Rotatório para Tamanho do Pincel -->
                        <div class="flex items-center space-x-2">
                            <label id="brushSizeLabel" class="text-sm font-semibold text-teal-700 w-10 text-right">5px</label>
                            <div id="brushKnobContainer" title="Gire para ajustar o tamanho do pincel">
                                <div id="brushKnob" class="relative">
                                    <div id="knobHandle"></div>
                                </div>
                            </div>
                        </div>

                        <button id="clearDrawingBtn" class="btn bg-red-500 hover:bg-red-600 px-4 py-2 text-sm">Limpar Desenho</button>
                    </div>

                    <!-- Container dos Acessórios -->
                    <div id="accessoriesContainer">
                        <!-- Itens de Acessório serão inseridos aqui pelo JS -->
                    </div>
                </div>
            `;
            
            drawingCanvas = document.getElementById('drawingCanvas');
            if (drawingCanvas) {
                drawingCtx = drawingCanvas.getContext('2d');
            } else {
                drawingCtx = null;
            }

            const resizeCanvas = () => {
                if (drawingCanvas) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = drawingCanvas.width;
                    tempCanvas.height = drawingCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(drawingCanvas, 0, 0);

                    drawingCanvas.width = drawingCanvas.parentElement.offsetWidth;
                    drawingCanvas.height = drawingCanvas.parentElement.offsetHeight;
                    
                    if (drawingCtx) {
                        drawingCtx.lineJoin = 'round';
                        drawingCtx.lineCap = 'round';
                        drawingCtx.drawImage(tempCanvas, 0, 0);
                    }
                }
            };
            
            const drawingArea = document.getElementById('drawingArea');
            
            accessories.forEach(acc => {
                drawingArea.appendChild(acc);
                acc.style.zIndex = acc === activeAccessory ? 11 : 10;
            });
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            const accessoriesContainer = document.getElementById('accessoriesContainer');
            accessoriesContainer.innerHTML = defaultAccessories.map((acc, index) => `
                <div class="accessory-item" data-index="${index}" title="${acc.name}">
                    <img src="${acc.src}" alt="${acc.name}" onerror="this.onerror=null; this.src='https://placehold.co/80x50/37474f/ffffff?text=${acc.name.substring(0, 10)}'">
                    <span>${acc.name}</span>
                </div>
            `).join('');
            
            document.querySelectorAll('.accessory-item').forEach(item => {
                item.addEventListener('click', () => {
                    const index = parseInt(item.getAttribute('data-index'));
                    addAccessory(defaultAccessories[index]);
                });
            });

            const setTool = (tool) => {
                currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`).classList.add('active');
                
                if (tool === 'brush' || tool === 'eraser') {
                    drawingCanvas.classList.add('drawing-active');
                    setActiveAccessory(null);
                } else {
                    drawingCanvas.classList.remove('drawing-active');
                }
            };

            document.getElementById('toolSelect').addEventListener('click', () => setTool('select'));
            document.getElementById('toolBrush').addEventListener('click', () => setTool('brush'));
            document.getElementById('toolEraser').addEventListener('click', () => setTool('eraser'));
            
            document.getElementById('brushColor').addEventListener('input', (e) => { currentColor = e.target.value; });
            document.getElementById('clearDrawingBtn').addEventListener('click', () => { drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); });

            drawingCanvas.addEventListener('mousedown', handleDrawingStart);
            drawingCanvas.addEventListener('touchstart', handleDrawingStart, { passive: false });
            
            drawingArea.addEventListener('mousedown', startAction);
            drawingArea.addEventListener('touchstart', startAction, { passive: false });
            
            const knob = document.getElementById('brushKnob');
            if (knob) {
                knob.addEventListener('mousedown', startBrushKnobRotation);
                knob.addEventListener('touchstart', startBrushKnobRotation, { passive: false });
            }
            
            document.getElementById('cancelRemove').addEventListener('click', hideRemoveModal);

            setTool('select');
        }
        
        // --- Lógica de Inicialização e Troca de Abas ---

        function switchGame(gameName) {
            currentGame = gameName;
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.getAttribute('data-game') === gameName) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            if (gameName === 'confetti') {
                renderConfettiGameContent();
            } else if (gameName === 'faceCustomizer') {
                isConfettiGameRunning = false;
                renderFaceCustomizerContent();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('tabMenu').addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-btn')) {
                    const game = e.target.getAttribute('data-game');
                    switchGame(game);
                }
            });

            switchGame('confetti');

            updateBrushKnob(0);
        });
    </script>
</body>
</html>
